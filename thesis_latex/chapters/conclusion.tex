Isolating components of a kernel or larger programs from each other makes sense both for security reasons and for better scalability. But adapting existing code bases is time-consuming and complicates development and testing. This is also true, for example, when programs written for monolithic or unikernels have to be rewritten for microkernel-based systems like \md with isolated drivers and system components. The Ohua compiler tries to solve this problem by automatically identifying independent sections of a program and making them separate threads or processes, depending on the architecture chosen.\\

In this work we have looked at whether it is possible to compile programs with Ohua whose structure does not yet contain the desired independent components. Using the concrete example of a server application, we looked at which transformations are necessary to create a program in which the TCP/IP stack, the network interface and the user application are independent, stateful components. By means of a backend integration for the microkernel-based operating system \md, a program transformed in this way could be compiled directly from running on a uni- or monolithic kernel to running on a microkernel based OS. \\

To achieve this, the components must only be used once in the compiled program. The communication between them must be realized via the arguments of a single function call, and the control flow of the entire program must be adapted accordingly. As it turned out, part of this problem can be formally described by transformation to Continuation Passing Style and Defunctionalization, and could be further developed to transformations in Ohua. Other necessary steps are not possible without additional demands on the programmer. This includes, among other things, the identification of the target components if this is not apparent from the initial code structure. In general, lifting code into scope that was encapsulated in function or method calls is problematic because it is the programmer's responsibility to respect the constraints of the programming model, e.g. that function arguments need to be serializable for the selected backend. As the transformations that Ohua performs on the code become more complex, it may become more difficult for the programmer to know in which areas of the code to adhere to the programming model. \\

Comparing Ohua with other approaches for compartmentalization we have seen that Ohua is more flexible since it is not directly build upon a single input language, compiler toolchain or particular hardware mechanism. However, as we have seen in the adaption to \md, we face the same problems when it comes to adaptations between different operating systems, namely that system calls can not be automatically identified from the syntax and replaced by Ohua. It might be worthwhile to consider adding annotations to Ohuas API in future versions, to enable e.g. the automatic encapsulation of components or the use of different data transfer mechanisms. Otherwise the input program already needs to use appropriate system calls and components, which contradicts the original idea of being able to develop the code independently of the target architecture. \\

For further work, we therefore need to clearly distinguish which transformations we can and want to implement in Ohua, and which steps should be left to the programmer.  

